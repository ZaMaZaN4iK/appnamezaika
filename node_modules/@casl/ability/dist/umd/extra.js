(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.casl = global.casl || {}, global.casl.extra = {})));
}(this, (function (exports) { 'use strict';

function rulesToQuery(ability, action, subject, convert) {
  var query = {};
  var ignoreOperators = {};
  var rules = ability.rulesFor(action, subject);

  for (var i = 0; i < rules.length; i++) {
    var rule = rules[i];
    var op = rule.inverted ? '$and' : '$or';

    if (!rule.conditions) {
      if (rule.inverted) {
        return null;
      }

      if (query[op]) {
        delete query[op];
      }

      ignoreOperators[op] = true;
    } else if (!ignoreOperators.hasOwnProperty(op)) {
      query[op] = query[op] || [];
      query[op].push(convert(rule));
    }
  }

  return rules.length > 0 ? query : null;
}

var getRuleFields = function getRuleFields(rule) {
  return rule.fields;
};

function permittedFieldsOf(ability, action, subject) {
  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

  var fieldsFrom = options.fieldsFrom || getRuleFields;
  var uniqueFields = ability.possibleRulesFor(action, subject).slice(0).reverse().filter(function (rule) {
    return rule.matches(subject);
  }).reduce(function (fields, rule) {
    var names = fieldsFrom(rule);

    if (names) {
      var toggle = rule.inverted ? 'delete' : 'add';
      names.forEach(fields[toggle], fields);
    }

    return fields;
  }, new Set());

  return Array.from(uniqueFields);
}

exports.rulesToQuery = rulesToQuery;
exports.permittedFieldsOf = permittedFieldsOf;

Object.defineProperty(exports, '__esModule', { value: true });

})));
